<!DOCTYPE html>
<html xmlns:og="http://ogp.me/ns#" xmlns:fb="http://www.facebook.com/2008/fbml">
<head>
  <title>Krzysztof Zabłocki - iOS App Architecture, Part 2: Data parsing</title>
  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="description" content="Data parsing in iOS apps, Subjective guide to writing iOS apps.">

<meta name="author" content="Krzysztof Zabłocki">


<meta property="og:title" content="iOS App Architecture, Part 2: Data parsing" />
<meta property="og:description" content="Data parsing in iOS apps, Subjective guide to writing iOS apps." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.merowing.info/2014/04/subjective-guide-to-writing-ios-apps-part-2-data-parsing/" />



<meta property="og:updated_time" content="2014-04-03 00:00:00 &#43;0000 UTC"/>


<meta property="og:site_name" content="Krzysztof Zabłocki" />







<meta property="article:author" content="https://www.facebook.com/krzysztof.zablocki" />
<meta property="article:publisher" content="https://www.facebook.com/krzysztof.zablocki" />
<meta property="article:published_time" content="2014-04-03 00:00:00 &#43;0000 UTC" />
<meta property="article:section" content="post" />

<meta property="article:tag" content="Architecture " />

<meta property="article:tag" content="iOS " />

<meta property="article:tag" content="Tutorial" />


<meta property="fb:app_id" content="406961899319006" />


<meta itemprop="name" content="iOS App Architecture, Part 2: Data parsing">
<meta itemprop="description" content="Data parsing in iOS apps, Subjective guide to writing iOS apps.">





<meta itemprop="keywords" content="animation,animations,architecture,clean-code,development-process,engineering,experiments,fitness,gamedev,general,growth,interface-builder,ios,ios-tips,leading,library,mindset,mvvm,open-source,process,psychology,reading,ruby,runtime,script,swift,tip,tools,tutorial,uix," />


<meta itemprop="wordCount" content="3928">


<meta name="twitter:card" content="summary"/>



<meta name="twitter:title" content="iOS App Architecture, Part 2: Data parsing"/>
<meta name="twitter:description" content="Data parsing in iOS apps, Subjective guide to writing iOS apps."/>
<meta name="twitter:site" content="@merowing_"/>
<meta name="twitter:creator" content="@merowing_"/>



  <link rel="canonical" href="https://www.merowing.info/2014/04/subjective-guide-to-writing-ios-apps-part-2-data-parsing/">

  <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">


  
  <link href="/css/prism.css" rel="stylesheet" />
  <link href="/css/about.css" rel="stylesheet" />

  <link rel="stylesheet" type="text/css" href="https://www.merowing.info/css/combined-min.css">
</head>
<body class="">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" type="text/javascript"></script>
<div class="site-wrap">
    <header class="site-header px2 px-responsive">
    <div class="mt2 wrap">
        <div class="measure">
            <nav class="site-nav left">
                <a href="https://www.merowing.info" class="site-title"><b>About</b></a>
            </nav>
            <nav class="site-nav right">
                <a href="/post/">Blog</a>

<a href="/speaking/">Speaking</a>
<a href="/sourcery-pro/">Sourcery Pro</a>


</form>
            </nav>
            <div class="clearfix"></div>
        </div>
    </div>
</header>

<div class="wrap measure center">
    <nav class="social-icons icons">
        
<a class="fa fa-twitter" href="https://twitter.com/merowing_"></a>



<a class="fa fa-github" href="https://github.com/krzysztofzablocki"></a>



<a class="fa fa-facebook" href="https://facebook.com/krzysztofzablocki"></a>



<a class="fa fa-linkedin" href="https://linkedin.com/pub/krzysztof-zab%c5%82ocki/26/200/442"></a>


<a class="fa fa-rss" href="/index.xml"></a>

    </nav>
</div>
    <div class="post p2 p-responsive wrap" role="main">
        <div class="measure">
            <div class="post-header mb2">
                <h1 class="h2 py2">iOS App Architecture, Part 2: Data parsing</h1>
                
                <span class="post-meta right"><i class="fa fa-clock-o"></i> <em>19 minute read</em></span>
                
                <br>

                
            </div>

            

            

            <article class="post-content">
                <p><a href="/2014/03/subjective-guide-to-writing-ios-apps-part-1-introduction">Last time</a> we set our project, this time we look at how we could create a simple yet flexible architecture for our model layer.</p>

<p></p>

<h2 id="design">Design</h2>

<p>What I like to do is create a modular architecture, one in which I can add new types of objects without modifying the core of the app, that way I can expand the application without much fuss.</p>

<p>Since UI will come later in this series, I&rsquo;ll write this part using tests.</p>

<h3 id="choices">Choices</h3>

<p>Let&rsquo;s start with a few choices before we design the architecture:</p>

<ul>
<li><a href="https://github.com/krzysztofzablocki/KZPropertyMapper">KZPropertyMapper</a> for data mapping - because it&rsquo;s simple.</li>
<li>CoreData for data persistence - because it&rsquo;s a very common need/choice in commercial apps.</li>
<li><a href="https://github.com/rentzsch/mogenerator">mogenerator</a> - as it&rsquo;s useful for creating human / machine files</li>
<li><a href="https://github.com/magicalpanda/MagicalRecord">Magical Record</a> - since we already know CoreData let&rsquo;s use a popular wrapper to help us out.</li>
<li><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> - a very popular library that I&rsquo;ll use for fetching data.</li>
<li><a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a> - this is not backend tutorial, so we&rsquo;ll stub server responses.</li>
<li><a href="https://github.com/allending/Kiwi">Kiwi</a> for tests -my favorite.</li>
</ul>

<p>I&rsquo;m not a huge fan of CoreData, but It gives me a nice way to have separation of concern.
When I use a Fetched Results Controller my UI can be automatically updated and I end up having something like this:</p>

<a href="/2014/04/Flow.png"
	
	
	class="image-gallery-photo"
	
>
	
		
		<img src="/2014/04/Flow.png"
			class="img-responsive
				"
			
			
			
				style="display: inline-block; "
			
			
			width="400"
			height="57"
		></img>
	
	
</a>



<p>In this article I&rsquo;ll talk about the data path.
<a href="https://github.com/krzysztofzablocki/KZBootstrap">Grab source code from GitHub</a></p>

<h2 id="implementation">Implementation</h2>

<p>First I start by setting up a project with <a href="https://github.com/krzysztofzablocki/crafter">crafter</a></p>

<pre><code class="language-bash">1. KZBootstrap
2. KZBootstrapTests
Which target should I use for default?
1
1. KZBootstrap
2. KZBootstrapTests
Which target should I use for tests?
2
do you want to add networking? [y/n]
y
do you want to add coredata? [y/n]
y
do you want to add kiwi? [y/n]
y
duplicating configurations
setting up variety of options
preparing git ignore
preparing pod file
adding scripts
Finished.
</code></pre>

<p>Using <a href="https://github.com/krzysztofzablocki/crafter">crafter</a> I now have all of my preferred libraries and custom warning levels without wasting time doing manual configuration.</p>

<h3 id="fetching">Fetching</h3>

<p>We won&rsquo;t be using a real backend server, instead we&rsquo;ll use the OHHTTPStubs library to stub network requests and return canned JSON responses. The library also provides us with simulated network speed (How cool is that?).</p>

<p>For this part we can get away with an extra simple DataProvider concept, it just needs to satisfy a few simple requirements:</p>

<ul>
<li>it should allow stubbing fake data for an arbitrary URL (because we don&rsquo;t have backend)</li>
<li>it should return operations that can be cancelled</li>
</ul>

<p>We can write tests for these 2 conditions like this:</p>

<pre><code class="language-objectivec">it(@&quot;should fetch data from an arbitrary URL&quot;, ^() {
  __block BOOL success = NO;
  [sut dataForURL:[NSURL URLWithString:@&quot;http://fake.url&quot;] withSuccessBlock:^(id responseData) {
    success = YES;
  } andFailureBlock:^(NSError *error) {
  }];

  [[expectFutureValue(@(success)) shouldEventually] beTrue];
});

it(@&quot;should return operations that can be canceled&quot;, ^() {
  __block BOOL executed = NO;
  id&lt;KZBCancelableOperation&gt; operation = [sut dataForURL:[NSURL URLWithString:@&quot;http://fake.url&quot;] withSuccessBlock:^(id responseData) {
    executed = YES;
  } andFailureBlock:^(NSError *error) {
    executed = YES;
  }];

  [operation cancel];
  [[expectFutureValue(@(executed)) shouldNotEventually] beTrue];
});
</code></pre>

<p>In the first test we only care that it succeeds, in the second test I&rsquo;m making sure that the operation can be cancelled.</p>

<p>Now to make the first test pass, we want to stub our network requests by using OHHTTPStubs:</p>

<pre><code class="language-objectivec">- (void)setupStubs
{
  [OHHTTPStubs removeAllStubs];
  [self.mapping enumerateKeysAndObjectsUsingBlock:^(NSString *urlPath, NSString *fileName, BOOL *stop) {
    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
      BOOL equal = [request.URL.absoluteString isEqualToString:urlPath];
      return equal;
    } withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
      OHHTTPStubsResponse *const response = [OHHTTPStubsResponse responseWithFileAtPath:OHPathForFileInBundle(fileName, nil) statusCode:200 headers:@{@&quot;Content-Type&quot; : @&quot;text/json&quot;}];
      response.responseTime = OHHTTPStubsDownloadSpeed3G;
      return response;
    }];
  }];
}
</code></pre>

<p>Here I setup all the stubbed network responses by using a mapping dictionary in form URLPath : FileName.</p>

<p>I also setup the stub to simulate the speed of a 3G connection since I want real async tests as we don&rsquo;t currently have a real UI</p>

<p>(In most cases you want to make tests run as fast as possible so that whole test-suite takes the minimum amount of time, since you&rsquo;ll be running them very often).</p>

<p>Implementing dataForURL is easy enough:</p>

<pre><code class="language-objectivec">- (id &lt;KZBCancelableOperation&gt;)dataForURL:(NSURL *)url withSuccessBlock:(KZBSuccessBlock)successBlock andFailureBlock:(KZBFailureBlock)failureBlock
{
  id requestOperation = [[AFHTTPRequestOperationManager manager] GET:url.absoluteString parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
    successBlock(responseObject);
  } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    if(operation.isCancelled) {
      return;
    }
    failureBlock(error);
  }];
  NSAssert([requestOperation respondsToSelector:@selector(cancel)], @&quot;Returned operation doesn't support KZBCancelableOperation protocol&quot;);
  return requestOperation;
}

</code></pre>

<p>Here I am using AFNetworking to do a simple fetch.</p>

<ul>
<li>I don&rsquo;t want a cancelled action to callback my completion blocks so I ignore cancelled operations with a guard clause.</li>
<li>I want to make sure requestOperation supports canceling.</li>
<li>Since I don&rsquo;t have any value in exposing AFNetworking internal classes to my code I&rsquo;ll be using my cancelable protocol.</li>
</ul>

<h3 id="parsing-data">Parsing data</h3>

<p>When it comes to parsing data, I&rsquo;d like to make sure this implementation handles a few requirements:</p>

<ol>
<li>Easy to modify source format, if I need to change from JSON to something else, then that shouldn&rsquo;t be a massive endeavor.</li>
<li>I&rsquo;d like to be able to add new types of objects without modifying the parsing core. Ideally I would just add a class and have it working.</li>
<li>Parsing should be very simple, preferably with little-to-no code.</li>
</ol>

<p>Let&rsquo;s look how we can create a design that will take care of all of these requirements:</p>

<h4 id="source-format">Source format</h4>

<p>This requirement is very simple to satisfy since we&rsquo;ll be using KZPropertyMapper for mapping.</p>

<p>It doesn&rsquo;t rely on JSON/XML or any other format. It uses native data structures, so the only thing we need to make sure of is that our parser converts the source format into native types before passing the data to KZPropertyMapper.</p>

<h4 id="supporting-new-classes">Supporting new classes</h4>

<p>This is the requirement that affects the design of this architecture the most.</p>

<p>I want to drop-in a new class to the project, and <em>&lsquo;somehow&rsquo;</em> have it picked up by the parser and handled.</p>

<h5 id="protocol">Protocol</h5>

<pre><code class="language-objectivec">@protocol KZBParsableObjectProtocol &lt;NSObject&gt;
@required
+ (NSString*)serverType;
+ (NSString*)serverIDPropertyName;
- (void)updateFromDictionary:(NSDictionary *)dictionary;
@end
</code></pre>

<p>Here we decide on 3 main features:</p>

<ol>
<li>We can define our own mapping for serverTypes, doing ORM with 1:1 naming is usually ugly, especially if you have to support multiple platforms.</li>
<li>We select which property will be used for mapping serverTypes.</li>
<li>Each object knows how to update itself from an NSDictionary*. In proper projects this might be a good place to return an error at the core parsing level, especially since KZPropertyMapper can generate validation errors for you.</li>
</ol>

<p>It&rsquo;s a nice simple protocol, but it doesn&rsquo;t help us automatically support any new classes.</p>

<h5 id="finding-parsable-classes">Finding parsable classes</h5>

<p>It&rsquo;s actually quite simple to use the Obj-C runtime to get a list of all classes that conform to our protocol.</p>

<p>Let&rsquo;s start with being able to find classes conforming to an arbitrary protocol:</p>

<pre><code class="language-objectivec"> it(@&quot;should be able to find classes conforming to specific protocol&quot;, ^() {
  [[[KZBParsingHelper findClassesConformingToProtocol:@protocol(KZBParsableObjectProtocol)] should] equal:@[KZBTestParsableClass.class]];
});
</code></pre>

<p>In order to make this simple test pass, we need to get our hands a little bit dirty and use the straight C API of the Obj-C runtime.</p>

<pre><code class="language-objectivec">+ (NSArray *)findClassesConformingToProtocol:(Protocol *)protocol
{
//! 1
  int numberOfClasses = objc_getClassList(NULL, 0);
  Class *classes;

//! 2
  classes = (Class *)malloc(sizeof(Class) * numberOfClasses);
  objc_getClassList(classes, numberOfClasses);

  NSMutableArray *conformingClasses = [NSMutableArray array];
  for (NSInteger i = 0; i &lt; numberOfClasses; i++) {
    Class lClass = classes[i];
//! 3
    if (class_conformsToProtocol(lClass, protocol)) {
      [conformingClasses addObject:classes[i]];
    }
  }

  free(classes);
  return [conformingClasses copy];
}
</code></pre>

<p>What happens here?</p>

<ol>
<li>First we need to establish the total number of classes in our application, so that we can allocate enough memory to hold them all.</li>
<li>We allocate memory for our classes array and then ask the runtime to fill this allocated memory with the classes.</li>
<li>While we are enumerating over all classes we need to use
~~~objectivec
class_conformsToProtocol
~~~
Instead of NSObject:
~~~objectivec
[class conformsToProtocol:]
~~~
This is because <strong>not all</strong> classes have to inherit from NSObject or implement the NSObject Protocol and that method will fail.</li>
</ol>

<p>Next we&rsquo;d like to be able to grab a class corresponding to a specific serverType value:</p>

<pre><code class="language-objectivec">it(@&quot;should be able to query class for a serverType&quot;, ^() {
  [[[KZBParsingHelper findClassesConformingToProtocol:@protocol(KZBParsableObjectProtocol)] should] contain:KZBTestParsableClass.class];
});
</code></pre>

<p>Now querying all the classes every time someone asks for a serverType would be <em>very wasteful and not very smart</em>.</p>

<p>Let&rsquo;s generate a serverType - class mapping only once when the KZBParsingHelper is first used:</p>

<pre><code class="language-objectivec">
//! 1.
+ (void)initialize
{
  [self setupServerTypeToClassMapping];
}

+ (void)setupServerTypeToClassMapping
{
//! 2.
  NSMutableDictionary *classMapping = [NSMutableDictionary new];
  for (Class lClass in [self findClassesConformingToProtocol:@protocol(KZBParsableObjectProtocol)]) {
    classMapping[[(id)lClass serverType]] = lClass;
  }
//! 3.
  NSArray *const serverTypes = classMapping.allValues;
  NSAssert([serverTypes count] == [[serverTypes valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;] count], @&quot;serverType collision, there shouldn't be 2 classes using same serverType %@&quot;, classMapping);

//! 4.
  objc_setAssociatedObject(self, serverTypeToClassMappingKey, classMapping, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

+ (Class)classForServerType:(NSString *)serverType
{
//! 5.
  return [objc_getAssociatedObject(self, serverTypeToClassMappingKey) objectForKey:serverType];
}
</code></pre>

<p>Let&rsquo;s elaborate:</p>

<ol>
<li>initialize is called when the class is first referenced, so when you first try to use any of the methods available in KZBParsingHelper it will execute.</li>
<li>Create a simple mapping between a serverType and the class that can map it.</li>
<li>Make sure that there aren&rsquo;t any duplicate serverTypes, since that would be programmer mistake.</li>
<li>Use associated objects to store the mappings against the class.</li>
<li>Use associated objects to retrieve a mapping from the class.</li>
</ol>

<h5 id="parser">Parser</h5>

<p>Let&rsquo;s define a simple DataParser protocol:</p>

<pre><code class="language-objectivec">@protocol KZBParserProtocol &lt;NSObject&gt;
- (void)parseData:(NSData *)data withCompletion:(void (^)(NSError *, NSDictionary *parsingInfo))completionBlock;
@end
</code></pre>

<ol>
<li>I don&rsquo;t see a need to define data types at this level, I&rsquo;d rather accept raw data and have the specific parser know how to handle it.</li>
<li>Even if you wanted to do the parsing synchronously (really?) I believe this should still be designed as an async interface.</li>
<li>Completion is called with error and parsingInfo, parsingInfo might be useful for specific parsers.</li>
</ol>

<h5 id="json-parser-coredata">JSON Parser &amp; CoreData</h5>

<p>Let&rsquo;s implement a base JSON parser that can work with CoreData, this will be a base class for implementing format specific JSON parsers later on.</p>

<pre><code class="language-objectivec">@interface KZBJSONParser : NSObject &lt;KZBParserProtocol&gt;
- (void)processBody:(id)jsonBody inContext:(NSManagedObjectContext *)localContext completion:(void (^)(NSError *, NSDictionary *))completionBlock ;
@end
</code></pre>

<p>Here we are adding one new method, subclasses can use it to define format specific parsing logic.</p>

<p>The implementation looks like this:</p>

<pre><code class="language-objectivec">
@implementation KZBJSONParser
//! 1.
- (void)parseData:(NSData *)jsonData withCompletion:(void (^)(NSError *, NSDictionary *))completionBlock
{
//! 2.
  NSParameterAssert(completionBlock);

  __block NSError *error;
  id obj = [self deserializeJSONData:jsonData error:&amp;error];
  if (!obj &amp;&amp; error) {
    completionBlock(error, nil);
    return;
  }

  __block NSDictionary *parserInfo;
//! 3.
  [MagicalRecord saveWithBlock:^(NSManagedObjectContext *localContext) {
    [self processBody:obj
          withCompletion:^(NSError *aError, NSDictionary *aParserInfo) {
            error = aError;
            parserInfo = aParserInfo;
          } inContext:localContext];
  } completion:^(BOOL success, NSError *aError) {
    if (!success &amp;&amp; aError) {
      error = pixle_NSErrorMake([NSString stringWithFormat:@&quot;Saving to CoreData failed with error %@&quot;, aError], kErrorCodeInternal, aError ? @{@&quot;parseError&quot; : aError} : nil, nil);
    }
    completionBlock(error, parserInfo);
  }];
}

//! 4.
- (void)processBody:(id)jsonBody withCompletion:(void (^)(NSError *, NSDictionary *))completionBlock inContext:(NSManagedObjectContext *)localContext
{
}

#pragma mark - Helpers
//! 5.
- (id)deserializeJSONData:(NSData *)data error:(NSError **)error
{
  if (data == nil) {
    if (error != NULL) {
      NSError *ourError = pixle_NSErrorMake(@&quot;JSON data is nil&quot;, kErrorCodeInternal, nil, nil);
      *error = ourError;
    }
    return nil;
  }
  id obj = [NSJSONSerialization JSONObjectWithData:data options:(NSJSONReadingOptions)0 error:error];
  return obj;
}
@end
</code></pre>

<ol>
<li>Concrete implementation of the base method from the Parser protocol.</li>
<li><strong>Parsing is an expensive operation</strong> and I&rsquo;d like to enforce no-one calls it without caring about the results.</li>
<li>Our JSON processing will happen on the CoreData context thread, and we&rsquo;ll pass in the localContext as I prefer to be explicit when working with context objects.</li>
<li>Stub method for subclasses.</li>
<li>Helper method for deserialising JSON using NSJSONSerialization.</li>
</ol>

<p>Now to be able to progress from here:</p>

<p>We need to know the JSON format coming from our servers.</p>

<p>As nice as REST is, not every client you have to work with have proper REST services, sometimes you might need to handle custom endpoints.</p>

<h3 id="server-api">Server API?</h3>

<p>While I was lead dev at <a href="http://theappbusiness.com">TAB</a> one of our apps had a diff-like API:</p>

<p>We would query an endpoint and we&rsquo;d get a response with list of actions to execute on our iOS app.</p>

<p>Let&rsquo;s define something similar for our tests:</p>

<pre><code class="language-json">{
    &quot;actions&quot;: [
        {
            &quot;type&quot;: &quot;add&quot;,
            &quot;payload&quot;: {
                &quot;serverId&quot; : &quot;0&quot;,
                &quot;serverType&quot; : &quot;TextWidget&quot;,
                &quot;title&quot;: &quot;My test title&quot;
            }
        },
        {
            &quot;type&quot;: &quot;add&quot;,
            &quot;payload&quot;: {
                &quot;serverId&quot;: &quot;2&quot;,
                &quot;serverType&quot;: &quot;ImageWidget&quot;,
                &quot;url&quot;: &quot;http://goo.gl/IFSk4C&quot;
            }
        }],
    &quot;nextUrl&quot; : null
}
</code></pre>

<p>We have 2 sections in our response:</p>

<ol>
<li>actions - this is an array of actions to execute in a specific order. Each action has a type and a payload.</li>
<li>nextUrl - the next fetch request should use this url. This way we can drive the whole API flow and only hardcode the &lsquo;start&rsquo; endpoint in our app.</li>
</ol>

<p>Let&rsquo;s implement a JSON Diff parser to handle our custom format, with some space for extensibility later on.</p>

<h4 id="json-diff-parser">JSON Diff parser</h4>

<p>The nice thing about our base JSON parser is the fact that we only need to override one method to implement our diff format:</p>

<pre><code class="language-objectivec">- (void)processBody:(id)jsonBody withCompletion:(void (^)(NSError *, NSDictionary *))completionBlock inContext:(NSManagedObjectContext *)localContext;
</code></pre>

<p>Let&rsquo;s define some simple requirements for our diff parser:</p>

<ul>
<li>should raise an exception for JSON format</li>
<li>should succeed for proper JSON format</li>
<li>should ignore non implemented actions</li>
<li>should create a new object for the add action</li>
</ul>

<p>To satisfy the first 2 requirements we can write tests like this:</p>

<pre><code class="language-objectivec">//! 1.
  it(@&quot;should raise exception for corrupted JSON format&quot;, ^() {
    [[theBlock(^() {
      [sut processBody:[sut deserializeJSONData:DataForDiffFile(invalid) error:nil] withCompletion:^
      (NSError *aError, NSDictionary *dictionary) {
      } inContext:[NSManagedObjectContext MR_context]];
    }) should] raise];
  });

//! 2.
  it(@&quot;should succeed for proper JSON format&quot;, ^() {
    __block NSNumber *result = nil;
    [sut parseData:DataForDiffFile(valid) withCompletion:^(NSError *error, NSDictionary *dictionary) {
      result = @(error == nil);
    }];

    [[expectFutureValue(result) shouldEventually] beYes];
  });
</code></pre>

<ol>
<li>This test is not perfect as I had to manually deserialise JSON and use processBody instead of the standard method, this is due to having to raise an exception asynchronously, if you know how to write a test that can work with the default method, <a href="http://twitter.com/merowing_">send me a tweet</a>.</li>
<li>We want to get a completion callback and make sure there weren&rsquo;t any errors.</li>
</ol>

<p>We can make these 2 tests pass with a simple implementation like:</p>

<pre><code class="language-objectivec">- (void)processBody:(id)jsonBody withCompletion:(void (^)(NSError *, NSDictionary *))completionBlock inContext:(NSManagedObjectContext *)localContext
{
  [super processBody:jsonBody withCompletion:completionBlock inContext:localContext];

  AssertTrueOrReturnBlock([jsonBody isKindOfClass:NSDictionary.class], ^(NSError *error) {
    completionBlock(error, nil);
  });

  NSString *nextURL = jsonBody[@&quot;nextUrl&quot;];
  AssertTrueOrReturnBlock((id)nextURL == [NSNull null] || [nextURL isKindOfClass:NSString.class], ^(NSError *error) {
    completionBlock(error, nil);
  });

  NSArray *actions = jsonBody[@&quot;actions&quot;];
  AssertTrueOrReturnBlock([actions isKindOfClass:NSArray.class], ^(NSError *error) {
    completionBlock(error, nil);
  });

  [actions enumerateObjectsUsingBlock:^(NSDictionary *action, NSUInteger idx, BOOL *stop) {
    AssertTrueOrReturnBlock([action isKindOfClass:NSDictionary.class], ^(NSError *error) {
      *stop = YES;
      completionBlock(error, nil);
    });

    AssertTrueOrReturnBlock([action[@&quot;type&quot;] isKindOfClass:NSString.class], ^(NSError *error) {
			*stop = YES;
      completionBlock(error, nil);
    });
  }];
}

</code></pre>

<p>Here we assert on expected types using <a href="http://www.merowing.info/2013/07/expanded-use-of-asserts/#.Uz2g1K2Sx1M">my advanced asserts</a>, that way it won&rsquo;t crash when compiled for release.</p>

<p><strong>But</strong> this code already looks a little bit crowded, and not that flexible, so let&rsquo;s refactor it to prepare for the next steps:</p>

<pre><code class="language-objectivec">
- (void)processBody:(id)jsonBody withCompletion:(void (^)(NSError *, NSDictionary *))completionBlock inContext:(NSManagedObjectContext *)localContext
{
  [super processBody:jsonBody withCompletion:completionBlock inContext:localContext];

  AssertTrueOrReturnBlock([jsonBody isKindOfClass:NSDictionary.class], ^(NSError *error) {
    completionBlock(error, nil);
  });
//! 1.
  NSMutableDictionary *parsingInfo = [NSMutableDictionary new];
  NSError *error = [self processSections:jsonBody parsingInfo:parsingInfo inContext:localContext];
  if (error) {
    completionBlock(error, parsingInfo);
    return;
  }

  completionBlock(nil, parsingInfo);
}

- (NSError *)processSections:(NSDictionary *)sections parsingInfo:(NSMutableDictionary *)parsingInfo inContext:(NSManagedObjectContext *)context
{
  __block NSError *oError;
  [sections enumerateKeysAndObjectsUsingBlock:^(NSString *section, id sectionData, BOOL *stop) {
    AssertTrueOrReturnBlock([section isKindOfClass:NSString.class], ^(NSError *error) {
      *stop = YES;
      oError = error;
    });
    //! 2.
    SEL selector = [self selectorForHandlingSection:section];
    if (![self respondsToSelector:selector]) {
      DDLogWarn(@&quot;Ignoring json diff section %@&quot;, section);
      return;
    }
    //! 3.
    id (*objc_msgSendTyped)(id, SEL, id, NSMutableDictionary *, NSManagedObjectContext *context) = (void *)objc_msgSend;
    NSError *error = objc_msgSendTyped(self, selector, sectionData, parsingInfo, context);
    if (error) {
      *stop = YES;
      oError = error;
    }
  }];

  return oError;
}

//! 4.
#pragma mark - Parsing sections
- (NSError *)processActions:(id)actionsArray parsingInfo:(NSMutableDictionary *)parsingInfo inContext:(NSManagedObjectContext *)context  __used
{
  __block NSError *oError;

  AssertTrueOrReturnError([actionsArray isKindOfClass:NSArray.class]);
  [actionsArray enumerateObjectsUsingBlock:^(NSDictionary *actionData, NSUInteger idx, BOOL *stop) {
    AssertTrueOrReturnBlock([actionData isKindOfClass:NSDictionary.class], ^(NSError *error) {
      *stop = YES;
      oError = error;
    });

    AssertTrueOrReturnBlock([actionData[@&quot;type&quot;] isKindOfClass:NSString.class], ^(NSError *error) {
      *stop = YES;
      oError = error;
    });

    SEL selector = [self selectorForHandlingAction:actionData[@&quot;type&quot;]];
    if (![self respondsToSelector:selector]) {
      DDLogWarn(@&quot;Ignoring json diff action %@&quot;, actionData);
      return;
    }


    id (*objc_msgSendTyped)(id, SEL, NSDictionary *, NSManagedObjectContext *context) = (void *)objc_msgSend;
    NSError *error = objc_msgSendTyped(self, selector, actionData, context);
    if (error) {
      *stop = YES;
      oError = error;
    }
  }];

  return oError;
}

- (NSError *)processNextUrl:(NSString *)nextURL parsingInfo:(NSMutableDictionary *)parsingInfo inContext:(NSManagedObjectContext *)context __used
{
  AssertTrueOrReturnError((id)nextURL == [NSNull null] || [nextURL isKindOfClass:NSString.class]);
  return nil;
}

#pragma mark - Helpers

- (SEL)selectorForHandlingSection:(NSString *)section
{
  return NSSelectorFromString([NSString stringWithFormat:@&quot;process%@:parsingInfo:inContext:&quot;, [section MR_capitalizedFirstCharacterString]]);
}
</code></pre>

<p>Even though there is more code with extra methods this is easier to read and future-proofed:</p>

<ol>
<li>Parsing all sections is now done in a separate method.</li>
<li>We now have dynamic resolution of section handling, which means we don&rsquo;t hardcode supported sections, this can be very useful in the future of the project, when you need to add support for new sections, I&rsquo;ll show an example later on.</li>
<li>We use a typed objc_msgSend to call the selector, this is due to the fact that we need to be careful about types when working with ARC and arm64.</li>
<li>The previous code has been refactored into separate methods that are called dynamically, don&rsquo;t forget to use <strong>__used</strong> keyword to prevent compiler from thinking this code is dead.</li>
</ol>

<p>We have 2 remaining requirements:</p>

<ol>
<li>should ignore non implemented actions</li>
<li>should create a new object for the add action</li>
</ol>

<p>The <em>1st</em> requirement is tested with same code as the success requirement, only using different JSON file.</p>

<p>The <em>2nd</em> one is more complicated:</p>

<ul>
<li>we need some test classes that use our CoreData model.</li>
<li>we need to make sure our CoreData is set-up correctly for testing.</li>
<li>we need to finish our processActions section handling.</li>
</ul>

<p>Let&rsquo;s start with a very basic data model:</p>

<a href="/2014/04/Model.png"
	
	
	class="image-gallery-photo"
	
>
	
		
		<img src="/2014/04/Model.png"
			class="img-responsive
				"
			
			
			
				style="display: inline-block; "
			
			
			width="344"
			height="219"
		></img>
	
	
</a>



<p>To be able to write tests with CoreData I&rsquo;d recommend using beforeEach/afterEach blocks in Kiwi, this is how they look after adding CD memory store:</p>

<pre><code class="language-objectivec">     __block KZBJSONDiffParser *sut;
      beforeEach(^{
        [MagicalRecord setupCoreDataStackWithInMemoryStore];

        sut = [KZBJSONDiffParser new];
      });

      afterEach(^{
        [MagicalRecord cleanUp];
      });

      it(@&quot;should ignore non implemented actions&quot;, ^() {
        __block NSNumber *result = nil;
        [sut parseData:DataForDiffFile(newactions) withCompletion:^(NSError *error, NSDictionary *dictionary) {
          result = (error == nil ? @YES : @NO);
        }];

        [[expectFutureValue(result) shouldEventually] beYes];
      });

      it(@&quot;should create a new object for the add action&quot;, ^() {
        __block id object = nil;
        [sut parseData:DataForDiffFile(valid) withCompletion:^(NSError *error, NSDictionary *dictionary) {
          object = [KZBTextWidget MR_findFirst];
        }];

        [[expectFutureValue(object) shouldEventually] beNonNil];
      });
</code></pre>

<p>Now we need to expand our processActions method to actually do something constructive.</p>

<p>Since we added a nice flexible way for dealing with section sections, let&rsquo;s replicate that for actions as well:</p>

<pre><code class="language-objectivec">    SEL selector = [self selectorForHandlingAction:actionData[@&quot;type&quot;]];
    if (![self respondsToSelector:selector]) {
      DDLogWarn(@&quot;Ignoring json diff action %@&quot;, actionData);
      return;
    }

    id (*objc_msgSendTyped)(id, SEL, id) = (void *)objc_msgSend;
    NSError *error = objc_msgSendTyped(self, selector, actionData);
    if (error) {
      *stop = YES;
      oError = error;
    }
</code></pre>

<p>For the actionAdd itself, you can implement it like this:</p>

<pre><code class="language-objectivec">- (NSError *)actionAdd:(NSDictionary *)action inContext:(NSManagedObjectContext *)context __used
{
  action = action[@&quot;payload&quot;];
  AssertTrueOrReturnNil([action isKindOfClass:NSDictionary.class]);

  NSString *serverType = action[@&quot;serverType&quot;];
  AssertTrueOrReturnNil([serverType isKindOfClass:NSString.class]);

  NSString *serverID = action[@&quot;serverId&quot;];
  AssertTrueOrReturnNil([serverID isKindOfClass:NSString.class]);

  NSManagedObject &lt;KZBParsableObjectProtocol&gt; *obj = [KZBParsingHelper findOrCreateWithServerType:serverType serverID:serverID inContext:context];
  [obj updateFromDictionary:action];

  return nil;
}
</code></pre>

<ul>
<li>We are only interested in payload at this point.</li>
<li>Asserts to make sure our format is matching expectations</li>
<li>Only soft-errors, if we return an Error from here it will stop the whole parsing, instead I&rsquo;d like to ignore incorrect data in this particular case, so I am using Asserts but not returning errors (my asserts already generate and log error info).</li>
<li>findOrCreate object and ask it to update itself from the action dictionary.</li>
</ul>

<p>Keep in mind that in normal projects:</p>

<ul>
<li>I&rsquo;d recommend having a separate helper for CoreData stuff.</li>
<li>findOrCreate should be optimised, doing it per action is too slow when you have lots of them. It&rsquo;s quite simple to optimise it but beyond scope of this article.</li>
</ul>

<p>This is how findOrCreate is implemented in ParsingHelper:</p>

<pre><code class="language-objectivec">+ (NSManagedObject &lt;KZBParsableObjectProtocol&gt; *)findOrCreateWithServerType:(NSString *)serverType serverID:(NSString *)serverID inContext:(NSManagedObjectContext *)context
{
  Class oClass = nil;
  NSManagedObject &lt;KZBParsableObjectProtocol&gt; *obj = [self findWithServerType:serverType serverID:serverID inContext:context classForObject:&amp;oClass];
  if (!obj &amp;&amp; oClass) {
    obj = [oClass MR_createInContext:context];
    [obj setValue:serverID forKey:[(id)oClass serverIDPropertyName]];
  }
  return obj;
}

+ (NSManagedObject &lt;KZBParsableObjectProtocol&gt; *)findWithServerType:(NSString *)serverType serverID:(NSString *)serverID inContext:(NSManagedObjectContext *)context classForObject:(out Class *)oClass
{
  Class classForObject = [KZBParsingHelper classForServerType:serverType];
  if (oClass) {
    *oClass = classForObject;
  }
  if (!classForObject) {
    DDLogInfo(@&quot;Ignoring object with serverType %@ as there is no matching class&quot;, serverType);
    return nil;
  }

  AssertTrueOrReturnNilBlock([self checkIfClass:classForObject isKindOfClass:NSManagedObject.class], ^(NSError *error) {
    if (oClass) {
      *oClass = nil;
    }
  });
  NSString *const serverIDProperty = [(id)classForObject serverIDPropertyName];
  NSManagedObject &lt;KZBParsableObjectProtocol&gt; *obj = [classForObject MR_findFirstByAttribute:serverIDProperty withValue:serverID inContext:context];
  return obj;
}
</code></pre>

<ul>
<li>We ignore serverTypes that don&rsquo;t have a matching class</li>
<li>We assert this parsable object is a managed object since this is a CoreData method.</li>
<li>We try finding an existing object. If one doesn&rsquo;t exist but we have found a proper class we use this class to create a new instance.</li>
</ul>

<p>Now all tests pass. Our architecture is finally ready to parse some data.</p>

<h4 id="parsing-object-data">Parsing object data</h4>

<p>Let&rsquo;s add parsing to our ImageWidget, since we spennt some time creating a nice architecture, it&rsquo;s going to be very straightforward.</p>

<p>First let&rsquo;s see if we can get our URL parsed correctly and transformed into an NSURL.</p>

<pre><code class="language-objectivec">it(@&quot;should create ImageWidget with properly parsed data&quot;, ^() {
  __block KZBImageWidget *imageWidget = nil;
  [sut parseData:DataForDiffFile(valid) withCompletion:^(NSError *error, NSDictionary *dictionary) {
    imageWidget = [KZBImageWidget MR_findFirst];
  }];

  [[expectFutureValue(imageWidget.url) shouldEventually] equal:[NSURL URLWithString:@&quot;http://goo.gl/IFSk4C&quot;]];
});
</code></pre>

<p>So how hard is it to add support for parsing image widgets with this architecture?</p>

<pre><code class="language-objectivec">//! in .h
@interface KZBImageWidget : _KZBImageWidget &lt;KZBParsableObjectProtocol&gt;{}

//! in .m
@implementation KZBImageWidget

+ (NSString *)serverType
{
  return @&quot;ImageWidget&quot;;
}

- (void)updateFromDictionary:(NSDictionary *)dictionary
{
  [KZPropertyMapper mapValuesFrom:dictionary toInstance:self usingMapping:@{
    @&quot;url&quot; : KZBox(URL, url),
    @&quot;caption&quot; : KZProperty(caption)
  }];
}
@end
</code></pre>

<p>And that&rsquo;s it. Pretty simple isn&rsquo;t it? You just conform to the protocol, specify the class and describe the mapping.</p>

<h4 id="yeah-right">Yeah right</h4>

<p>That was really simple data, what if I&rsquo;d like to have a CoreData relationship? It&rsquo;s probably going to be <em>dreadful and hard</em>?</p>

<p><strong>Not really</strong>.</p>

<p>Let&rsquo;s say our server architecture changes and we need to add a relationship between ImageWidget and TextWidget:</p>

<pre><code class="language-json"> {
            &quot;type&quot;: &quot;add&quot;,
            &quot;payload&quot;: {
                &quot;serverId&quot;: &quot;2&quot;,
                &quot;serverType&quot;: &quot;ImageWidget&quot;,
                &quot;url&quot;: &quot;http://goo.gl/IFSk4C&quot;,
                &quot;caption&quot; : &quot;it works!&quot;,
				&quot;textWidgetId&quot; : &quot;0&quot;
            }
        }
</code></pre>

<p>How can we change our parsing to handle this? 2 Options:</p>

<ol>
<li>Add boxing in a category to be able to create objects like that, preferable if you need to repeat this kind of mapping in multiple places.</li>
<li>Just use KZCall to create sub-object:</li>
</ol>

<p>First let&rsquo;s add test for our new requirement:</p>

<pre><code class="language-objectivec">it(@&quot;should create ImageWidget with properly parsed relationship&quot;, ^() {
  __block BOOL isEqual = NO;
  [sut parseData:DataForDiffFile(valid) withCompletion:^(NSError *error, NSDictionary *dictionary) {
    KZBImageWidget *imageWidget = [KZBImageWidget MR_findFirst];
    KZBTextWidget *textWidget = [KZBTextWidget MR_findFirst];
    isEqual = imageWidget &amp;&amp; imageWidget.textWidget == textWidget;
  }];

  [[expectFutureValue(@(isEqual)) shouldEventually] beTrue];
});
</code></pre>

<p>Now we need to update our KZBImageWidget parsing like this:</p>

<pre><code class="language-objectivec">- (void)updateFromDictionary:(NSDictionary *)dictionary
{
  [KZPropertyMapper mapValuesFrom:dictionary toInstance:self usingMapping:@{
    @&quot;url&quot; : KZBox(URL, url),
    @&quot;caption&quot; : KZProperty(caption),
    @&quot;textWidgetId&quot; : KZCall(objectForId:, textWidget)
  }];
}

- (id)objectForId:(NSString *)serverID
{
  AssertTrueOrReturnNil([serverID isKindOfClass:NSString.class]);
  return [KZBParsingHelper findWithServerType:[KZBWidget serverType] serverID:serverID inContext:self.managedObjectContext];
}
</code></pre>

<p>Looks simple enough?</p>

<ol>
<li>Use KZCall to specify the selector to be called with textWidgetId value, the resulting value should be assigned to the textWidget property.</li>
<li>objectForId method that will query ANY subclass of KZBWidget that has specific serverID.</li>
</ol>

<p>I&rsquo;ve implemented objectForId without textWidgetType because you could move this code to KZPropertyMapper as a new boxing and have it used in ALL your relationships if needed.</p>

<p>KZPM offers more than we used here:</p>

<ul>
<li>It does compile time checking for your property / method names</li>
<li>Allows extra simple expansion by using categories</li>
<li>Offers simple validation logic with a custom DSL syntax</li>
</ul>

<p><a href="https://github.com/krzysztofzablocki/KZPropertyMapper">Read more at it&rsquo;s github page.</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>By now you should know how to create simple, yet flexible architecture.
I also hope you noticed that by writing tests, you can find your mistakes and verify assumptions with ease.</p>

<h4 id="keep-in-mind">Keep in mind</h4>

<ul>
<li>In normal projects you should definitely have more tests and they could be refactored a little bit.</li>
<li>This is the general idea, but it&rsquo;s a good start, I&rsquo;d adapt it to project specific needs.</li>
</ul>

<p><a href="https://github.com/krzysztofzablocki/KZBootstrap">Grab source code from GitHub</a></p>
            </article>
            <a href="https://twitter.com/merowing_" class="twitter-follow-button" data-show-count="true"
                data-size="medium"></a>
            <br />
            <br />
            <hr>
            <a href="https://merowing.info/sourcery-pro/" class="p">
                If you hate writing repetitive code <b>SourceryPro</b> is here.
            </a>
            <p>
                Want to optimize your development workflow?
                <a href="mailto:krzysztof.zablocki@pixle.pl?Subject=I%20want%20to%20hire%20you" class="p">I'd love to
                    help your
                    team.
            </p>
            <div class="social-icons">
                <p>Share this post:</p>
                <div class="addthis_sharing_toolbox left" data-url="https://www.merowing.info/2014/04/subjective-guide-to-writing-ios-apps-part-2-data-parsing/" data-title="iOS App Architecture, Part 2: Data parsing"></div>
            </div>
            <div class="clearfix"></div>

            </br>
            
            </br>
            </br>

            <p class="post-meta">tags:&nbsp;
                
                
                <a href="https://www.merowing.info/tags/architecture%20">Architecture </a>
                
                ,&nbsp;
                <a href="https://www.merowing.info/tags/ios%20">iOS </a>
                
                ,&nbsp;
                <a href="https://www.merowing.info/tags/tutorial">Tutorial</a>
                
            </p>
        </div>
    </div>
</div>

<script>!function (d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (!d.getElementById(id)) {
            js = d.createElement(s);
            js.id = id;
            js.src = "//platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js, fjs);
        }
    }(document, "script", "twitter-wjs");</script>





<footer class="footer">
    <div class="p2 wrap">
        <div class="measure mt1 center">
            <nav class="social-icons icons">
    
<a class="fa fa-twitter" href="https://twitter.com/merowing_"></a>



<a class="fa fa-github" href="https://github.com/krzysztofzablocki"></a>



<a class="fa fa-facebook" href="https://facebook.com/krzysztofzablocki"></a>



<a class="fa fa-linkedin" href="https://linkedin.com/pub/krzysztof-zab%c5%82ocki/26/200/442"></a>


<a class="fa fa-rss" href="/index.xml"></a>

</nav>

            <small>
                Krzysztof Zabłocki <br/>
                Copyright &#169; 2012-2021<br>
                Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; based on <a
                    href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
            </small>
        </div>
    </div>
</footer>

<script src="/js/prism.js"></script>
<script src="/js/carousel.js"></script>




<script src="/lightgallery/js/lightgallery.min.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js"></script>


<script src="/lightgallery/js/lg-thumbnail.min.js"></script>
<script src="/lightgallery/js/lg-fullscreen.min.js"></script>

<script type="text/javascript">
    $(document).ready(function () {
        $('.lightgallery').lightGallery({
            thumbnail: true
        });
    });
</script>



<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-29400340-1', 'auto');
  ga('send', 'pageview');

</script>



<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-532368630eb37492" async="async"></script>
<script type="text/javascript">
var addthis_share = addthis_share || {}
addthis_share = {
	passthrough : {
		twitter: {
			via: "merowing_"
		}
	}
}
</script>
</body>
</html>
